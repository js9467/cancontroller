#include "can_manager.h"
#include "hardware_config.h"

#include <driver/twai.h>
#include <freertos/FreeRTOS.h>
#include <Wire.h>
#include <ESP_IOExpander_Library.h>

#include <algorithm>

CanManager& CanManager::instance() {
    static CanManager manager;
    return manager;
}

bool CanManager::begin(gpio_num_t tx_pin, gpio_num_t rx_pin, std::uint32_t bitrate) {
    tx_pin_ = tx_pin;
    rx_pin_ = rx_pin;
    bitrate_ = bitrate;

    Serial.printf("[CanManager] Initializing TWAI on TX=GPIO%d, RX=GPIO%d, Bitrate=%lu\n", tx_pin_, rx_pin_, bitrate_);

    // CRITICAL: Ensure CAN mode is FORCED on before starting TWAI
    // This must happen regardless of previous state
    Serial.println("[CanManager] Setting CAN transceiver to ENABLED...");
    setCanMode(true);
    delay(10);  // Hardware settle time

    twai_general_config_t g_config = TWAI_GENERAL_CONFIG_DEFAULT(tx_pin_, rx_pin_, TWAI_MODE_NORMAL);
    g_config.tx_queue_len = 8;
    g_config.rx_queue_len = 16;
    g_config.alerts_enabled = TWAI_ALERT_TX_SUCCESS | TWAI_ALERT_TX_FAILED | TWAI_ALERT_BUS_ERROR | TWAI_ALERT_BUS_OFF | TWAI_ALERT_ERR_PASS;

    if (bitrate_ != 250000) {
        Serial.println("[CanManager] Unsupported bitrate requested. Falling back to 250 kbps.");
    }

    const twai_timing_config_t t_config = TWAI_TIMING_CONFIG_250KBITS();
    const twai_filter_config_t f_config = TWAI_FILTER_CONFIG_ACCEPT_ALL();

    if (twai_driver_install(&g_config, &t_config, &f_config) != ESP_OK) {
        Serial.println("[CanManager] Failed to install TWAI driver");
        ready_ = false;
        return false;
    }

    if (twai_start() != ESP_OK) {
        Serial.println("[CanManager] Failed to start TWAI driver");
        ready_ = false;
        return false;
    }

    ready_ = true;
    Serial.println("[CanManager] TWAI bus ready at 250 kbps");
    return true;
}

void CanManager::stop() {
    if (!ready_) {
        return;
    }
    twai_stop();
    twai_driver_uninstall();
    ready_ = false;
    Serial.println("[CanManager] TWAI driver stopped");
}

bool CanManager::sendButtonAction(const ButtonConfig& button) {
    if (!button.can.enabled) {
        Serial.printf("[CanManager] Button '%s' has no CAN frame assigned\n", button.label.c_str());
        return false;
    }
    return sendFrame(button.can);
}

bool CanManager::sendButtonReleaseAction(const ButtonConfig& button) {
    if (!button.can_off.enabled) {
        Serial.printf("[CanManager] Button '%s' has no CAN OFF frame assigned\n", button.label.c_str());
        return false;
    }
    return sendFrame(button.can_off);
}

bool CanManager::sendFrame(const CanFrameConfig& frame) {
    if (!ready_) {
        Serial.println("[CanManager] TWAI bus not initialized");
        return false;
    }

    // Check for bus errors and recover if needed
    twai_status_info_t status;
    if (twai_get_status_info(&status) == ESP_OK) {
        if (status.state == TWAI_STATE_BUS_OFF) {
            Serial.println("[CanManager] Bus-off detected, initiating recovery");
            twai_initiate_recovery();
            vTaskDelay(pdMS_TO_TICKS(100));
        } else if (status.state == TWAI_STATE_RECOVERING) {
            Serial.println("[CanManager] Bus is recovering, waiting...");
            vTaskDelay(pdMS_TO_TICKS(50));
        }
    }

    twai_message_t message = {};
    message.identifier = buildIdentifier(frame);
    message.extd = 1;
    message.data_length_code = frame.length;  // Use actual data length, not frame.data.size()
    for (std::size_t i = 0; i < frame.length; ++i) {
        message.data[i] = frame.data[i];
    }

    // VERBOSE LOGGING: Show exactly what we're sending
    Serial.printf("[CanManager] TX Frame: ID=0x%08lX, Len=%d, Data=", 
                  static_cast<unsigned long>(message.identifier), message.data_length_code);
    for (std::size_t i = 0; i < message.data_length_code; ++i) {
        Serial.printf("%02X ", message.data[i]);
    }
    Serial.println();
    Serial.printf("[CanManager]   PGN=0x%05lX, Pri=%u, SA=0x%02X, DA=0x%02X\n",
                  static_cast<unsigned long>(frame.pgn), frame.priority, 
                  frame.source_address, frame.destination_address);

    esp_err_t result = twai_transmit(&message, pdMS_TO_TICKS(50));
    if (result != ESP_OK) {
        Serial.printf("[CanManager] ✗ TX FAILED (err=%d)\n", static_cast<int>(result));
        // Log the bus state for debugging
        if (twai_get_status_info(&status) == ESP_OK) {
            Serial.printf("[CanManager]   Bus state: %d, TX errors: %lu, RX errors: %lu\n",
                         status.state, status.tx_error_counter, status.rx_error_counter);
        }
        return false;
    }

    Serial.println("[CanManager] ✓ TX SUCCESS");
    return true;
}

std::uint32_t CanManager::buildIdentifier(const CanFrameConfig& frame) const {
    const std::uint8_t priority = frame.priority & 0x7;
    const std::uint8_t data_page = (frame.pgn >> 16) & 0x01;
    const std::uint8_t pdu_format = (frame.pgn >> 8) & 0xFF;
    std::uint8_t pdu_specific = frame.pgn & 0xFF;

    if (pdu_format < 240) {
        // PDU1 - destination specific
        pdu_specific = frame.destination_address;
    }

    return (static_cast<std::uint32_t>(priority) << 26) |
           (static_cast<std::uint32_t>(0) << 25) |
           (static_cast<std::uint32_t>(data_page) << 24) |
           (static_cast<std::uint32_t>(pdu_format) << 16) |
           (static_cast<std::uint32_t>(pdu_specific) << 8) |
           (static_cast<std::uint32_t>(frame.source_address));
}

bool CanManager::receiveMessage(CanRxMessage& msg, uint32_t timeout_ms) {
    if (!ready_) {
        return false;
    }

    twai_message_t rx_msg;
    esp_err_t result = twai_receive(&rx_msg, pdMS_TO_TICKS(timeout_ms));
    
    if (result != ESP_OK) {
        return false;
    }

    msg.identifier = rx_msg.identifier;
    msg.length = rx_msg.data_length_code;
    msg.timestamp = millis();
    
    for (uint8_t i = 0; i < msg.length && i < 8; i++) {
        msg.data[i] = rx_msg.data[i];
    }

    return true;
}

std::vector<CanRxMessage> CanManager::receiveAll(uint32_t timeout_ms) {
    std::vector<CanRxMessage> messages;
    
    uint32_t start_time = millis();
    while (millis() - start_time < timeout_ms) {
        CanRxMessage msg;
        if (receiveMessage(msg, 10)) {
            messages.push_back(msg);
        } else {
            break;
        }
    }
    
    return messages;
}

// Helper for J1939 PGN transmission (non-blocking, no ACK wait)
bool CanManager::sendJ1939Pgn(uint8_t priority, uint32_t pgn, uint8_t source_addr, const uint8_t data[8]) {
    if (!ready_) {
        Serial.println("[CanManager] TWAI not ready");
        return false;
    }

    // Build J1939 29-bit identifier: [Priority(3) | Reserved(1) | DataPage(1) | PDU Format(8) | PDU Specific(8) | Source Address(8)]
    uint32_t identifier = ((uint32_t)(priority & 0x7) << 26) | ((pgn & 0x3FFFF) << 8) | source_addr;

    twai_message_t msg = {};
    msg.identifier = identifier;
    msg.extd = 1;  // Extended 29-bit ID
    msg.data_length_code = 8;
    memcpy(msg.data, data, 8);

    // Non-blocking transmit with 50ms timeout
    esp_err_t result = twai_transmit(&msg, pdMS_TO_TICKS(50));
    if (result != ESP_OK) {
        Serial.printf("[CanManager] TX queue fail: %s\n", esp_err_to_name(result));
        return false;
    }

    Serial.printf("[CanManager] TX PGN=0x%05lX data=%02X %02X %02X %02X %02X %02X %02X %02X\n",
                  (unsigned long)pgn, data[0], data[1], data[2], data[3], 
                  data[4], data[5], data[6], data[7]);
    return true;
}

// Background task for Infinitybox Output1 ON sequence
static void infinityboxOutput1OnTask(void* pvParameters) {
    const uint8_t SA_TOOL = 0x80;
    const uint32_t PGN_FF01 = 0x00FF01;
    const uint32_t PGN_FF02 = 0x00FF02;

    vTaskDelay(pdMS_TO_TICKS(100));  // Let web handler return first

    Serial.println("[Task] Infinitybox Output1 ON sequence starting");

    // Baseline FF02 00
    uint8_t ff02_00[8] = {0x00, 0, 0, 0, 0, 0, 0, 0};
    if (CanManager::instance().sendJ1939Pgn(6, PGN_FF02, SA_TOOL, ff02_00)) {
        vTaskDelay(pdMS_TO_TICKS(10));

        // FF01 A0 00
        uint8_t ff01_a0[8] = {0xA0, 0x00, 0, 0, 0, 0, 0, 0};
        if (CanManager::instance().sendJ1939Pgn(6, PGN_FF01, SA_TOOL, ff01_a0)) {
            vTaskDelay(pdMS_TO_TICKS(10));

            // FF02 80 00
            uint8_t ff02_80[8] = {0x80, 0x00, 0, 0, 0, 0, 0, 0};
            if (CanManager::instance().sendJ1939Pgn(6, PGN_FF02, SA_TOOL, ff02_80)) {
                vTaskDelay(pdMS_TO_TICKS(10));

                // FF01 20 00
                uint8_t ff01_20[8] = {0x20, 0x00, 0, 0, 0, 0, 0, 0};
                if (CanManager::instance().sendJ1939Pgn(6, PGN_FF01, SA_TOOL, ff01_20)) {
                    vTaskDelay(pdMS_TO_TICKS(10));

                    // FF02 back to 00
                    CanManager::instance().sendJ1939Pgn(6, PGN_FF02, SA_TOOL, ff02_00);
                }
            }
        }
    }

    Serial.println("[Task] Infinitybox Output1 ON sequence complete");
    vTaskDelete(NULL);
}

// Non-blocking wrapper - starts background task
bool CanManager::sendInfinityboxOutput1On() {
    if (!ready_) {
        Serial.println("[CanManager] TWAI not ready");
        return false;
    }
    if (xTaskCreate(infinityboxOutput1OnTask, "Inf1On", 2048, NULL, 1, NULL) == pdTRUE) {
        Serial.println("[CanManager] Started Output1 ON background task");
        return true;
    }
    return false;
}

// Background task for Infinitybox Output1 OFF sequence
static void infinityboxOutput1OffTask(void* pvParameters) {
    const uint8_t SA_TOOL = 0x80;
    const uint32_t PGN_FF01 = 0x00FF01;
    const uint32_t PGN_FF02 = 0x00FF02;

    Serial.println("[Task] Infinitybox Output1 OFF sequence starting");

    uint8_t ff02_00[8] = {0x00, 0, 0, 0, 0, 0, 0, 0};
    uint8_t ff01_20[8] = {0x20, 0x00, 0, 0, 0, 0, 0, 0};

    CanManager::instance().sendJ1939Pgn(6, PGN_FF02, SA_TOOL, ff02_00);
    vTaskDelay(pdMS_TO_TICKS(10));
    CanManager::instance().sendJ1939Pgn(6, PGN_FF01, SA_TOOL, ff01_20);
    vTaskDelay(pdMS_TO_TICKS(10));
    CanManager::instance().sendJ1939Pgn(6, PGN_FF02, SA_TOOL, ff02_00);

    Serial.println("[Task] Infinitybox Output1 OFF sequence complete");
    vTaskDelete(NULL);
}

// Non-blocking wrapper - starts background task
bool CanManager::sendInfinityboxOutput1Off() {
    if (!ready_) {
        Serial.println("[CanManager] TWAI not ready");
        return false;
    }
    if (xTaskCreate(infinityboxOutput1OffTask, "Inf1Off", 2048, NULL, 1, NULL) == pdTRUE) {
        Serial.println("[CanManager] Started Output1 OFF background task");
        return true;
    }
    return false;
}

// Background task for Infinitybox Output9 ON sequence
// EXACT 5-message sequence from working sketch
static void infinityboxOutput9OnTask(void* pvParameters) {
    const uint8_t SA_TOOL = 0x80;
    const uint32_t PGN_FF01 = 0x00FF01;
    const uint32_t PGN_FF02 = 0x00FF02;

    vTaskDelay(pdMS_TO_TICKS(100));  // Let web handler return first

    Serial.println("[Task] Infinitybox Output9 ON sequence starting (5 messages)");

    uint8_t ff02_00[8] = {0x00, 0, 0, 0, 0, 0, 0, 0};
    uint8_t ff02_80[8] = {0x80, 0x00, 0, 0, 0, 0, 0, 0};
    uint8_t ff01_2080[8] = {0x20, 0x80, 0, 0, 0, 0, 0, 0};

    // Message 1: FF02 00
    if (CanManager::instance().sendJ1939Pgn(6, PGN_FF02, SA_TOOL, ff02_00)) {
        vTaskDelay(pdMS_TO_TICKS(10));
        // Message 2: FF01 20 80
        if (CanManager::instance().sendJ1939Pgn(6, PGN_FF01, SA_TOOL, ff01_2080)) {
            vTaskDelay(pdMS_TO_TICKS(10));
            // Message 3: FF02 80
            if (CanManager::instance().sendJ1939Pgn(6, PGN_FF02, SA_TOOL, ff02_80)) {
                vTaskDelay(pdMS_TO_TICKS(10));
                // Message 4: FF01 20 80 (repeat)
                if (CanManager::instance().sendJ1939Pgn(6, PGN_FF01, SA_TOOL, ff01_2080)) {
                    vTaskDelay(pdMS_TO_TICKS(10));
                    // Message 5: FF02 00
                    CanManager::instance().sendJ1939Pgn(6, PGN_FF02, SA_TOOL, ff02_00);
                }
            }
        }
    }

    Serial.println("[Task] Infinitybox Output9 ON sequence complete");
    vTaskDelete(NULL);
}

// Non-blocking wrapper - starts background task
bool CanManager::sendInfinityboxOutput9On() {
    if (!ready_) {
        Serial.println("[CanManager] TWAI not ready");
        return false;
    }
    if (xTaskCreate(infinityboxOutput9OnTask, "Inf9On", 4096, NULL, 1, NULL) == pdTRUE) {
        Serial.println("[CanManager] Started Output9 ON background task");
        return true;
    }
    return false;
}

// Background task for Infinitybox Output9 OFF sequence
// EXACT 3-message sequence from working sketch
static void infinityboxOutput9OffTask(void* pvParameters) {
    const uint8_t SA_TOOL = 0x80;
    const uint32_t PGN_FF01 = 0x00FF01;
    const uint32_t PGN_FF02 = 0x00FF02;

    vTaskDelay(pdMS_TO_TICKS(100));  // Let web handler return first

    Serial.println("[Task] Infinitybox Output9 OFF sequence starting (3 messages)");

    uint8_t ff02_00[8] = {0x00, 0, 0, 0, 0, 0, 0, 0};
    uint8_t ff01_20[8] = {0x20, 0x00, 0, 0, 0, 0, 0, 0};

    // Message 1: FF02 00
    if (CanManager::instance().sendJ1939Pgn(6, PGN_FF02, SA_TOOL, ff02_00)) {
        vTaskDelay(pdMS_TO_TICKS(10));
        // Message 2: FF01 20 00
        if (CanManager::instance().sendJ1939Pgn(6, PGN_FF01, SA_TOOL, ff01_20)) {
            vTaskDelay(pdMS_TO_TICKS(10));
            // Message 3: FF02 00
            CanManager::instance().sendJ1939Pgn(6, PGN_FF02, SA_TOOL, ff02_00);
        }
    }

    Serial.println("[Task] Infinitybox Output9 OFF sequence complete");
    vTaskDelete(NULL);
}

// Non-blocking wrapper - starts background task
bool CanManager::sendInfinityboxOutput9Off() {
    if (!ready_) {
        Serial.println("[CanManager] TWAI not ready");
        return false;
    }
    if (xTaskCreate(infinityboxOutput9OffTask, "Inf9Off", 4096, NULL, 1, NULL) == pdTRUE) {
        Serial.println("[CanManager] Started Output9 OFF background task");
        return true;
    }
    return false;
}
// ============================================================================
// DIAGNOSTIC FUNCTIONS - Verify hardware is actually working
// ============================================================================

// ============================================================================
// CAN MODE CONTROL - Forcefully set the transceiver enable pin
// ============================================================================

void CanManager::setCanMode(bool enable) {
    // Force the CAN transceiver to ON or OFF by setting EXIO5 (USB_SEL) on the CH422G expander
    // This is a static function that can be called even before CanManager is fully initialized
    
    Serial.printf("[CanManager] setCanMode(%s) called\n", enable ? "TRUE" : "FALSE");
    
    // Access the global IO expander (initialized in main.cpp)
    if (!g_io_expander) {
        Serial.println("[CanManager] ⚠️  CRITICAL ERROR: g_io_expander is NULL!");
        Serial.println("[CanManager]   This means the expander wasn't initialized before CAN");
        Serial.println("[CanManager]   CAN transceiver will remain DISABLED");
        return;
    }
    
    Serial.printf("[CanManager]   g_io_expander = 0x%p (valid pointer)\n", g_io_expander);
    
    // USB_SEL is EXIO5 (bit 5 on the CH422G)
    // HIGH = CAN transceiver enabled (USB disabled)
    // LOW = USB enabled (CAN transceiver disabled)
    const uint8_t USB_SEL = 5;  // EXIO5
    
    Serial.printf("[CanManager]   Calling digitalWrite(pin=%d, value=%s)\n", 
                  USB_SEL, enable ? "HIGH" : "LOW");
    
    g_io_expander->digitalWrite(USB_SEL, enable ? HIGH : LOW);
    
    Serial.printf("[CanManager] \u2713 USB_SEL set to %s\n", enable ? "HIGH (CAN mode)" : "LOW (USB mode)");
    
    // Give the transceiver time to stabilize
    delay(5);
    
    // Verify by reading RX pin state
    pinMode(static_cast<gpio_num_t>(19), INPUT);
    int rx_state = digitalRead(static_cast<gpio_num_t>(19));
    Serial.printf("[CanManager]   RX pin (GPIO19) reads: %s\n", rx_state ? "HIGH" : "LOW");
}

// ============================================================================
// DIAGNOSTIC - Practical verification only
// ============================================================================

void CanManager::dumpHardwareStatus() const {
    Serial.println("\n╔════════════════════════════════════════════════════════╗");
    Serial.println("║        CAN HARDWARE DIAGNOSTIC STATUS                  ║");
    Serial.println("╚════════════════════════════════════════════════════════╝");
    
    // TWAI driver status
    Serial.printf("├─ TWAI Driver Status: %s\n", ready_ ? "READY ✓" : "NOT READY ✗");
    Serial.printf("├─ TX Pin: GPIO%d, RX Pin: GPIO%d\n", tx_pin_, rx_pin_);
    Serial.printf("├─ Bitrate: %lu bps\n", bitrate_);
    
    // TWAI bus status - THIS is how we verify things work
    if (ready_) {
        twai_status_info_t status;
        if (twai_get_status_info(&status) == ESP_OK) {
            const char* state_str = "UNKNOWN";
            switch (status.state) {
                case TWAI_STATE_STOPPED: state_str = "STOPPED"; break;
                case TWAI_STATE_RUNNING: state_str = "RUNNING"; break;
                case TWAI_STATE_BUS_OFF: state_str = "BUS-OFF"; break;
                case TWAI_STATE_RECOVERING: state_str = "RECOVERING"; break;
            }
            Serial.printf("├─ Bus State: %s\n", state_str);
            Serial.printf("├─ TX Queue: %lu, RX Queue: %lu\n", status.msgs_to_tx, status.msgs_to_rx);
            Serial.printf("├─ TX Errors: %lu, RX Errors: %lu\n", status.tx_error_counter, status.rx_error_counter);
        }
    }
    
    // GPIO RX Pin State Check - THE REAL TEST: is pin connected and toggling?
    Serial.println("├─ GPIO RX Pin State (RAW GPIO READ - 100 samples over 100ms):");
    pinMode(rx_pin_, INPUT);
    uint32_t ones = 0;
    uint32_t zeros = 0;
    uint32_t last_state = digitalRead(rx_pin_);
    uint32_t transitions = 0;
    
    for (int i = 0; i < 100; i++) {
        uint32_t state = digitalRead(rx_pin_);
        if (state) ones++;
        else zeros++;
        if (state != last_state) transitions++;
        last_state = state;
        delayMicroseconds(1000);  // 1ms between samples
    }
    
    Serial.printf("  ones=%lu, zeros=%lu, transitions=%lu\n", ones, zeros, transitions);
    if (ones == 0 || zeros == 0) {
        Serial.println("  ⚠️  RX PIN STUCK - Transceiver likely disabled or not connected");
    } else if (transitions == 0) {
        Serial.println("  ⚠️  NO TRANSITIONS - Bus quiet or transceiver offline");
    } else {
        Serial.println("  ✓ Pin transitions detected - transceiver appears connected!");
    }
    
    Serial.println("└─ Diagnostic Complete\n");
}

String CanManager::getHardwareStatusJson() const {
    String json = "{";
    json += "\"ready\":" + String(ready_ ? "true" : "false") + ",";
    json += "\"tx_pin\":" + String(tx_pin_) + ",";
    json += "\"rx_pin\":" + String(rx_pin_) + ",";
    json += "\"bitrate\":" + String(bitrate_) + ",";
    
    // TWAI bus status
    if (ready_) {
        twai_status_info_t status;
        if (twai_get_status_info(&status) == ESP_OK) {
            const char* state_str = "UNKNOWN";
            switch (status.state) {
                case TWAI_STATE_STOPPED: state_str = "STOPPED"; break;
                case TWAI_STATE_RUNNING: state_str = "RUNNING"; break;
                case TWAI_STATE_BUS_OFF: state_str = "BUS-OFF"; break;
                case TWAI_STATE_RECOVERING: state_str = "RECOVERING"; break;
            }
            json += "\"bus_state\":\"" + String(state_str) + "\",";
            json += "\"tx_queue\":" + String(status.msgs_to_tx) + ",";
            json += "\"rx_queue\":" + String(status.msgs_to_rx) + ",";
            json += "\"tx_errors\":" + String(status.tx_error_counter) + ",";
            json += "\"rx_errors\":" + String(status.rx_error_counter) + ",";
        }
    }
    
    // GPIO RX Pin State Check
    pinMode(rx_pin_, INPUT);
    uint32_t ones = 0, zeros = 0, transitions = 0;
    uint32_t last_state = digitalRead(rx_pin_);
    
    for (int i = 0; i < 100; i++) {
        uint32_t state = digitalRead(rx_pin_);
        if (state) ones++;
        else zeros++;
        if (state != last_state) transitions++;
        last_state = state;
        delayMicroseconds(1000);
    }
    
    json += "\"rx_pin_ones\":" + String(ones) + ",";
    json += "\"rx_pin_zeros\":" + String(zeros) + ",";
    json += "\"rx_pin_transitions\":" + String(transitions) + ",";
    
    String diagnosis = "OK";
    if (ones == 0 || zeros == 0) {
        diagnosis = "RX_PIN_STUCK";
    } else if (transitions == 0) {
        diagnosis = "NO_TRANSITIONS";
    }
    json += "\"diagnosis\":\"" + diagnosis + "\"";
    
    json += "}";
    return json;
}

// ============================================================================
// SIMPLE CAN SNIFFER TEST - Proves transceiver is working
// ============================================================================

void CanManager::testReceive(uint32_t duration_ms) const {
    if (!ready_) {
        Serial.println("[CanManager] TWAI not ready - cannot test receive");
        return;
    }
    
    Serial.printf("\n[CanManager] CAN SNIFFER TEST - Listening for %lu ms...\n", duration_ms);
    Serial.println("[CanManager] If you see frames below, transceiver is WORKING ✓");
    Serial.println("[CanManager] If NO frames appear, transceiver is OFF or bus is quiet ✗\n");
    
    uint32_t start = millis();
    uint32_t frame_count = 0;
    
    while (millis() - start < duration_ms) {
        twai_message_t m;
        esp_err_t result = twai_receive(&m, pdMS_TO_TICKS(100));
        
        if (result == ESP_OK) {
            frame_count++;
            Serial.printf("[RX #%lu] %s ID=0x%08lX DLC=%d  ",
                frame_count,
                m.extd ? "EXT" : "STD",
                (unsigned long)m.identifier,
                m.data_length_code
            );
            for (int i = 0; i < m.data_length_code; i++) {
                Serial.printf("%02X ", m.data[i]);
            }
            Serial.println();
        }
    }
    
    Serial.printf("\n[CanManager] Test complete: %lu frames received in %lu ms\n", frame_count, duration_ms);
    if (frame_count == 0) {
        Serial.println("[CanManager] ⚠️  NO FRAMES RECEIVED - CHECK:");
        Serial.println("  1. Transceiver enable pin (should be HIGH)");
        Serial.println("  2. CANH/CANL wiring + GND reference");
        Serial.println("  3. Bitrate match (try 250k and 500k)");
        Serial.println("  4. Bus termination (120Ω at ends)");
        Serial.println("  5. Actual bus traffic present");
    }
}